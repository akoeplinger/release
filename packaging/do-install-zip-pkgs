#!/usr/bin/env python

#  File location is where the actual files will be installed
#  Relocation destination is where the files will eventually be run from

# Will be /tmp/build_deps for the packaging system


import sys
import distutils.dir_util
import utils
import os
import glob
import re

if len(sys.argv) < 3:
	print "Usage: ./do-install-zip-pkgs <file location> <relocation destination> [ full path to packages... ]"
	print "  Note: full path to packages is usually a glob"
	sys.exit(1)

dest = sys.argv[1]
reloc = sys.argv[2]

package_files = sys.argv[3:]

print " *** Installing to %s for destination %s *** " % (dest, reloc)

if not os.path.exists(dest):
	distutils.dir_util.mkpath(dest)

os.chdir(dest)


for package_file in package_files:
	utils.extract_file(package_file)


### Change prefix in the .pc files ###
parameter_map = {}
# Note: using substitute_parameters_in_file uses re.sub, and using ^ works best with re.M, otherwise
#  the ^ only matches at the beginning of the string
parameter_map[re.compile("^prefix=.*", re.M)] = "prefix=" + reloc

# for all of the .pc files
for root, dirs, files in os.walk('.'):
	for file in files:
		if re.compile('\.pc$').search(file):
			utils.substitute_parameters_in_file(os.path.join(root, file), re.compile(''), parameter_map)

# Write out an env.sh in the $RELOC dir so we can use that when we build
# This needs to by dynamic
env = open('env.sh', 'w')
env.write('export PKG_CONFIG_PATH=%s/lib/pkgconfig:$PKG_CONFIG_PATH\n' % reloc)
env.write('export PATH=%s/bin:$PATH\n' % reloc)

# Needed for the solaris builds so far
env.write('export LDFLAGS=-L%s/lib\n' % reloc)
env.write('export CPPFLAGS=-I%s/include\n' % reloc)
env.write('export LD_LIBRARY_PATH=%s/lib:$LD_LIBRARY_PATH\n' % reloc)

env.close()
os.chmod('env.sh', 0755)

# Write out csh environment file
env = open('env.csh', 'w')
env.write('setenv PKG_CONFIG_PATH %s/lib/pkgconfig:$PKG_CONFIG_PATH\n' % reloc)
env.write('setenv PATH %s/bin:$PATH\n' % reloc)

env.write('setenv LDFLAGS -L%s/lib\n' % reloc)
env.write('setenv CPPFLAGS -I%s/include\n' % reloc)
env.write('setenv LD_LIBRARY_PATH %s/lib:$LD_LIBRARY_PATH\n' % reloc)

env.close()
os.chmod('env.csh', 0755)

# Fake out .la files (for solaris, win32 doesn't seem to need this
parameter_map = {}
parameter_map[re.compile("^libdir=.*", re.M)] = "libdir='" + reloc + "/lib'"
parameter_map[re.compile("/usr/local")] = reloc
parameter_map[re.compile("/opt/csw")] = reloc
parameter_map[re.compile("/tmp/install")] = reloc

for root, dirs, files in os.walk('.'):
	for file in files:
		if re.compile('\.la$').search(file):
			utils.substitute_parameters_in_file(os.path.join(root, file), re.compile(''), parameter_map)



os.chdir('bin')

# Only do this for cygwin (basically for monodoc for gtk-sharp2)
if os.path.exists('c:/cygwin/usr/'):
	print "Making cygwin specific massages to bin/* wrappers..."
	parameter_map = {}
	parameter_map[re.compile("^prefix=/usr", re.M)] = "prefix=C:/cygwin/usr"
	parameter_map[re.compile("^monodocdir=/usr", re.M)] = "monodocdir=C:/cygwin/usr"

	for root, dirs, files in os.walk('.'):
		for file in files:
			# Search and replace in all files containing #!/bin/sh and /tmp/install
			utils.substitute_parameters_in_file(os.path.join(root, file), re.compile('#!/bin/sh.*/usr', re.M | re.DOTALL), parameter_map)


# Now for the rest of the files in bin
print "Massaging bin/* wrappers..."
parameter_map = {}
# For packages we build
parameter_map[re.compile("/tmp/install")] = reloc
# For packages we consume (noarch rpms)
parameter_map[re.compile("/usr")] = reloc

for root, dirs, files in os.walk('.'):
	for file in files:
		# Search and replace in all files containing #!/bin/sh and /tmp/install
		utils.substitute_parameters_in_file(os.path.join(root, file), re.compile('#!/bin/sh.*(/tmp/install|/usr)', re.M | re.DOTALL), parameter_map)

os.chdir('..')


# Avoids "Application Error" on win32 and allows scripts to be run
for file in glob.glob('bin/*'):
	os.chmod(file, 0755)



