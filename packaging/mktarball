#!/usr/bin/env python

# TODO: Catch sigint, and unlock jail...

import os
import sys
import distutils.dir_util
import glob
import commands

import pdb

sys.path += ['../pyutils' ]
import logger
import packaging
import utils
import datastore
import config

def usage():
	print ""
	print "Usage: ./mktarball <package> <version|snap> [svn rev]"
	print " where version is a tagged version from svn"
	print " Note: if you specify snap, you must specify svn rev"
	print ""


### Command line arg handling ###
if len(sys.argv) < 3:
	usage()
	sys.exit(1)

package=sys.argv[1]
if sys.argv[2] == "snap":
	try:
		version = sys.argv[3]
	except IndexError:
		usage()
		sys.exit(1)
	HEAD_or_RELEASE = "HEAD"
else:
	version=sys.argv[2]
	HEAD_or_RELEASE = "RELEASE"


### End of Command line arg handling ###

repo = datastore.source_file_repo()

# Check to see if this is already there
if repo.contains(HEAD_or_RELEASE, package, version):
	print "Source file for %s version %s (%s) exists" % (package, version, HEAD_or_RELEASE) 
	sys.exit(1)

LOGFILE = "%s/%s/%s/%s.log" % (config.mktarball_logs, HEAD_or_RELEASE, package, version)
log_obj = logger.Logger(filename=LOGFILE)


# Get tarball path from def file
package_obj = packaging.package("", package, HEAD_or_RELEASE=HEAD_or_RELEASE)
if package_obj.info.has_key('MKTARBALL_HOST'):
	distro = package_obj.info['MKTARBALL_HOST']
else:
	distro = config.mktarball_host

log_obj.log("Sources path: %s\n" % package_obj.source_fullpath)
log_obj.log("Using distro: %s\n" % distro)

env = packaging.buildenv(distro, logger=log_obj)

if env.is_locked():
	log_obj.log("%s jail is busy\n" % distro )
	sys.exit(2)

env.lock_env()

# Update tarball status to "inprogress"
repo.add_file(HEAD_or_RELEASE, package, version, "inprogress")

if package_obj.info.has_key('MONO_DEPS'):
	(status, output) = utils.launch_process('./install-deps %s %s' % (distro, package), logger=log_obj)
	if status:
		env.unlock_env()
		log_obj.log("Dependency installation failed\n")
		sys.exit(3)


# Copy some files over and execute!
# Also copy over def_alias files
files_to_copy = [ 'do-msvn-tar', 'defs/%s' % package] + glob.glob('../pyutils/*.py') 
for f in package_obj.get_aliases():
	files_to_copy += ['defs/' + f ]
env.ssh.copy_to(files_to_copy, '/tmp', mode='scp')

log_obj.log("Starting to build source dist...\n")
(status, output) = env.ssh.execute('mount /proc &> /dev/null', exec_as_root=1)
(status, output) = env.ssh.execute('/tmp/do-msvn-tar %s %s %s' % (HEAD_or_RELEASE, package, version) )

if status:
        env.unlock_env()
        log_obj.log("Source dist file creation failed\n")
	repo.add_file(HEAD_or_RELEASE, package, version, "failure")
        sys.exit(1)

# get tarball filename
tarball = output.split().pop()

# Copy file back
#  Note: the tarball var is expected to have be in this format, ex:  mono-1.1.13.4.tar.gz
env.ssh.copy_from('/tmp/built-tarball/%s' % tarball, package_obj.source_fullpath)

# Keep a map of which params produce which tarball
repo.add_file(HEAD_or_RELEASE, package, version, package_obj.source_relpath + os.sep + tarball)

env.unlock_env()

print "Done!"

