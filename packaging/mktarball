#!/usr/bin/env python

# TODO: Catch sigint, and unlock jail...

import os
import sys
import distutils.dir_util
import glob
import commands
import getopt

import pdb

sys.path += ['../pyutils' ]
import logger
import packaging
import utils
import datastore
import config

def usage():
	print ""
	print "Usage: ./mktarball [--snapshot] [--force] <package> <version|svn rev>"
	print " where version is a tagged released version or an svn revision"
	print " Note: if you specify snapshot, you must specify 'svn rev' instead of 'version'"
	print " --force is used to override an already existing tarball, "
	print "   or retry a version that's know to fail"
	print ""

HEAD_or_RELEASE = "RELEASE"
force = False
opts, remaining_args = getopt.getopt(sys.argv[1:], "", [ "snapshot", "force" ])
for option, value in opts:
        if option == "--snapshot":
                 HEAD_or_RELEASE = "HEAD"
        if option == "--force":
                 force = True

### Command line arg handling ###
try:
	(package, version) = remaining_args
except:
	usage()
	sys.exit(1)

### End of Command line arg handling ###

repo = datastore.source_file_repo()

# Check to see if this is already there (if we haven't used the force option to override)
if repo.contains(HEAD_or_RELEASE, package, version) and not force:
	# Check to see if the state is failure
        repo_info = repo.get_tarball_state_info(HEAD_or_RELEASE, package, read_info=False)
	if repo_info['state'][version] == "failure":
		print "Tarball creation for %s version %s (%s) failed already" % (package, version, HEAD_or_RELEASE) 
		print "  Use the --force option if you want to try again"
	else:
		print "Source file for %s version %s (%s) exists, use --force to override" % (package, version, HEAD_or_RELEASE) 
	sys.exit(1)

LOGFILE = "%s/%s/%s/%s.log" % (config.mktarball_logs, HEAD_or_RELEASE, package, version)
log_obj = logger.Logger(filename=LOGFILE)


# Get tarball path from def file
package_obj = packaging.package("", package, HEAD_or_RELEASE=HEAD_or_RELEASE)
if package_obj.info.has_key('MKTARBALL_HOST'):
	distro = package_obj.info['MKTARBALL_HOST']
else:
	distro = config.mktarball_host

log_obj.log("Sources path: %s\n" % package_obj.source_fullpath)
log_obj.log("Using distro: %s\n" % distro)

conf = packaging.buildconf(distro, logger=log_obj)

if conf.buildenv.is_locked():
	log_obj.log("%s jail is busy\n" % distro )
	sys.exit(2)

conf.buildenv.lock_env()

# Update tarball status to "inprogress"
repo.add_file(HEAD_or_RELEASE, package, version, "inprogress")

if package_obj.info.has_key('MONO_DEPS'):
	(status, output) = utils.launch_process('./install-deps --build_source %s %s' % (conf.conf_lock_filename, package), logger=log_obj)
	if status:
		conf.buildenv.unlock_env()
		log_obj.log("Dependency installation failed\n")
		repo.add_file(HEAD_or_RELEASE, package, version, "failure")
		sys.exit(3)


# Copy some files over and execute!
# Also copy over def_alias files
files_to_copy = [ 'do-msvn-tar', 'defs/%s' % package] + glob.glob('../pyutils/*.py') 
for f in package_obj.get_aliases():
	files_to_copy += ['defs/' + f ]
conf.buildenv.copy_to(files_to_copy, '/tmp', mode='scp')

log_obj.log("Starting to build source dist...\n")
(status, output) = conf.buildenv.execute_command('mount /proc &> /dev/null', exec_as_root=1)
(status, output) = conf.buildenv.execute_command('/tmp/do-msvn-tar %s %s %s' % (HEAD_or_RELEASE, package, version) )

if status:
        conf.buildenv.unlock_env()
        log_obj.log("Source dist file creation failed\n")
	repo.add_file(HEAD_or_RELEASE, package, version, "failure")
        sys.exit(1)

# get tarball filename
tarball = output.split().pop()

# Copy file back
#  Note: the tarball var is expected to have be in this format, ex:  mono-1.1.13.4.tar.gz
conf.buildenv.copy_from('/tmp/built-tarball/%s' % tarball, package_obj.source_fullpath)

# Keep a map of which params produce which tarball
repo.add_file(HEAD_or_RELEASE, package, version, package_obj.source_relpath + os.sep + tarball)

conf.buildenv.unlock_env()

print "Done!"

