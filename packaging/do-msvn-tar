#!/usr/bin/env python
#
# The driver script to make a tarball
#

import sys
import os
import tempfile
import shutil
import glob
import distutils.dir_util

import packaging

RELEASE_or_HEAD = sys.argv[1]
package = sys.argv[2]
version = sys.argv[3]


os.chdir('/tmp')

dummy_env = ""
package_obj = packaging.package(dummy_env, package)

if os.path.exists('tarball-creation'):
	shutil.rmtree('tarball-creation')
os.mkdir('tarball-creation')
os.chdir('tarball-creation')


# Construct subversion path of location we want to create a tarball from
svn_paths = []
if RELEASE_or_HEAD == "HEAD":
	rev_arg = "-r " + version
	if package_obj.info.has_key('HEAD_PATH'):
		svn_paths += package_obj.info['HEAD_PATH']

else:
	rev_arg = ""
	if package_obj.info.has_key('RELEASE_PATH'):
		svn_paths += package_obj.info['RELEASE_PATH']

	# Do some svn_path munging
	# (options: [[version]], [[versiondot]], [[gtksharp2ver]]
	version_dot = version
	version_hyphen = version.replace('.', '-')

	for i in range(0, len(svn_paths)):
		svn_paths[i] = svn_paths[i].replace('[[versiondot]]', version_dot)
		svn_paths[i] = svn_paths[i].replace('[[version]]', version_hyphen)

		# TODO where to handle gtk-sharp?



# use the key in /usr/share/ximian-build-system/conf/ssh
# This needs to be exported to the environment
SVN_SSH = "/usr/bin/bb_ssh"
SVNEXPORT = "svn export -q " + rev_arg
MONO_ROOT = " svn+ssh://distro@mono-cvs.ximian.com/source" 
SVN_PATHS = ":".join(svn_paths)
VERSION = version

# print env
print "SVN_SSH: %s" % SVN_SSH
print "SVNEXPORT: %s" % SVNEXPORT
print "MONO_ROOT: %s" % MONO_ROOT
print "RELEASE_or_HEAD: %s" % RELEASE_or_HEAD
print "SVN_PATHS: %s" % SVN_PATHS
print "VERSION: %s" % VERSION

env_string = 'export SVN_SSH="%s"; export SVNEXPORT="%s"; export MONO_ROOT="%s"; export RELEASE_or_HEAD="%s"; export SVN_PATHS="%s"; export VERSION="%s"' % (SVN_SSH, SVNEXPORT, MONO_ROOT, RELEASE_or_HEAD, SVN_PATHS, VERSION)

# If they don't have any svn_paths, they MUST specify BUILD_DIR
if package_obj.info.has_key('BUILD_DIR'):
	build_dir = package_obj.info['BUILD_DIR']
else:
	try:
		build_dir = os.path.basename(svn_paths[0])
	except:
		print "You must specify BUILD_DIR in def file when not using RELEASE or HEAD PATH"
		sys.exit(1)

# Maybe we'll eventually use python code in the def file someday...
default_script = """
update_version_file () {
	sed -i "s/\(AM_INIT_AUTOMAKE.*\\))/\\1.$VERSION)/" configure.in
}

make_dist () {
	# profile is needed on suse systems with gnome in /opt
	. /etc/profile
        ./autogen.sh
        make dist
}
"""


shell_script = tempfile.mktemp()
fd = open(shell_script, 'w')
fd.write(default_script)
fd.close()

# pwd: /tmp/tarball-creation

### Execute the source creating functions ###
def_file = "/tmp/" + package

# get_source
if package_obj.info.has_key('get_source'):
	script = def_file
	command = '%s; . %s ; get_source' % (env_string, script)
	print "Command: %s" % command
	os.system(command)
else:
	cache_dir = "/tmp/src_cache/%s/%s" % (package, RELEASE_or_HEAD)
	for path in svn_paths:
		module = os.path.basename(path)

		# Do we have a working copy already?
		if os.path.exists("%s/%s" % (cache_dir, module)):
			# svn switch  (will update update if the path in the working copy hasn't changed, this ensures have the right path)
			command = '%s; cd %s/%s; svn switch %s %s/%s' % (env_string, cache_dir, module, rev_arg, MONO_ROOT, path)
			print "Executing: " + command
			if os.system(command):
				print "*** Error *** updating cached copy failed (this is usually because of a malformed url, ex: invalid version, or bb_ssh failed)"
				sys.exit(1)
		else:
			# create cache dir
			if not os.path.exists(cache_dir): distutils.dir_util.mkpath(cache_dir)
			#check out working copy
			command = "%s; cd %s; svn checkout -q %s %s/%s" % (env_string, cache_dir, rev_arg, MONO_ROOT, path)
			print command
			os.system(command)


		# svn export from working copy
		#command = "%s; %s %s/%s" % (env_string, SVNEXPORT, MONO_ROOT, path)
		#command = "%s; %s %s/%s" % (env_string, SVNEXPORT, cache_dir, module)
		# Note: using -r rev with svn export from a local cache dir will connect to the svn server... bad

		#command = "%s; svn export -q %s/%s" % (env_string, cache_dir, module)
		#  svn export from a working dir pegs the processor at 99%!!  also bad... it also takes longer (3 minutes... ?)

		#  Use rsync instead?  probably...
		# results: using this instead of svn export recovers those 3 minutes
		command = "rsync -a --exclude '.svn/' %s/%s ." % (cache_dir, module)

		print command
		os.system(command)


# Go inside the source tree
os.chdir(build_dir)

# update_version_file (If this is a snapshot build)
if RELEASE_or_HEAD == "HEAD":
	if package_obj.info.has_key('update_version_file'):
		script = def_file
	else:
		script = shell_script
	os.system('%s; . %s ; update_version_file' % (env_string, script) )

# pwd: /tmp/tarball-creation/$build_dir

# make_dist
if package_obj.info.has_key('make_dist'):
	script = def_file
else:
	script = shell_script
os.system('%s; . %s ; make_dist' % (env_string, script) )

### End of source creating functions ###

# clean up shell files
os.unlink(shell_script)

# TODO
# Remove bb.ssh /tmp files?

### Finish moving things around
shutil.rmtree('/tmp/built-tarball')
os.mkdir('/tmp/built-tarball')

found_source_file = 0

# Move zip file
source_file = glob.glob('*.zip')
if len(source_file) == 1:
	os.rename(source_file[0], '/tmp/built-tarball/%s' % source_file[0])
	found_source_file = 1
	print "print source filename..."
	print source_file[0]

# Move tar file
source_file = glob.glob('*.tar.gz')
if len(source_file) == 1:
	os.rename(source_file[0], '/tmp/built-tarball/%s' % source_file[0])
	found_source_file = 1
	print "print source filename..."
	print source_file[0]

# Clean up
os.chdir('/tmp')
shutil.rmtree('tarball-creation')

# Propogate exit code
if not found_source_file:
	sys.exit(1)

