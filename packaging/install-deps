#!/usr/bin/env python
#
#    Usage: install-deps TARGET <package> <local packages>
#
#       where:
#           package is package to build to install deps for (can also be 'none')
#           local packages is packages in the defs dir and/or urls if distro is zip based
#


import os
import sys
import re
import glob
import time
import getopt

sys.path += ['../pyutils']

import packaging
import utils

import pdb

is_url = re.compile("^(ftp|http)", re.I)

# Default to RELEASE
HEAD_or_RELEASE = "RELEASE"
opts, remaining_args = getopt.getopt(sys.argv[1:], "", [ "HEAD_or_RELEASE=" ])
for option, value in opts:
        if option == "--HEAD_or_RELEASE":
		if value != "HEAD" and value != "RELEASE":
			print "HEAD_or_RELEASE must be either HEAD or RELEASE ..."
			sys.exit(1)
		HEAD_or_RELEASE = value

if len(remaining_args) < 2:
	print ""
	print "Usage: ./install-deps [ --HEAD_OR_RELEASE=[HEAD|RELEASE] ] TARGET <package> <local packages>"
	print " where:"
        print "   package is package to build to install deps for (can also be 'none')"
        print "   local packages is packages in the defs dir and/or urls if distro is zip based"
	print ""
	sys.exit(1)


target = remaining_args[0]
build_deps_package = remaining_args[1]


deps = []
if len(remaining_args) > 2: deps = remaining_args[2:]

target_env = packaging.buildenv(target, print_output=1)


files = []
if build_deps_package != 'none':
	package = packaging.package(target_env, build_deps_package, HEAD_or_RELEASE=HEAD_or_RELEASE)
	files += package.get_dep_files()

for dep in deps:
	if is_url.search(dep):
		utils.get_url(dep, 'external_zip_pkg')
		files += [ 'external_zip_pkg' + os.sep + os.path.basename(dep) ]

	else:	
		package = packaging.package(target_env, dep, HEAD_or_RELEASE=HEAD_or_RELEASE)
		files += package.get_files()
		files += package.get_dep_files()


# Remove duplciates
files = utils.remove_list_duplicates(files)


# Stop if no packages found
if len(files) == 0:
	print "No packages found..."
	sys.exit()

build_location = target_env.env_vars['build_location']

# Clean out deps area
(code, output) = target_env.ssh.execute("rm -rf %s/install-packages %s/build_deps" % (build_location, build_location) )
if code:
	print "Error cleaning up... exiting"
	sys.exit(1)
target_env.ssh.execute("mkdir -p -m777 %s/install-packages" % build_location)

# copy packages
# It would be nice to see the output...
target_env.ssh.copy_to(files, '%s/install-packages' % build_location, mode='scp', compress=0)

# Install the packages with rpm/rcd
if target_env.get_info_var('USE_ZIP_PKG'):

	target_env.ssh.copy_to(['do-install-zip-pkgs', '../pyutils/utils.py', '../pyutils/rpm2cpio.py'], '%s/install-packages' % build_location, mode='scp')
	# These must NOT be in the build_location, otherwise it will throw off the relocation
        (code, output) = target_env.ssh.execute( "%s/install-packages/do-install-zip-pkgs /tmp/build_deps /tmp/build_deps %s/install-packages/*" % (build_location, build_location) )

else:

        (code, rpm_names) = utils.launch_process("rpm -qp --queryformat '%%{NAME} ' %s" % " ".join(files))

        # Use rug if the jail has it
	(code, output) = target_env.ssh.execute('ls /usr/sbin/rcd')
	if not code:
                # check if rcd is running in this jail and start it if it isn't
		(code, output) = target_env.ssh.execute('rug ping')
		if code:
			target_env.ssh.execute('/usr/sbin/rcd -r', exec_as_root=1)
			print "Waiting for rcd to come alive..."
			time.sleep(5)
		target_env.ssh.execute('rug rm -y %s' % rpm_names, exec_as_root=1)
		(code, output) = target_env.ssh.execute('rug in -y -r %s/install-packages/*.rpm' % build_location, exec_as_root=1)
		target_env.ssh.execute('rug shutdown', exec_as_root=1)
        else:
		target_env.ssh.copy_to('remove-rpms', build_location)
		target_env.ssh.execute('%s/remove-rpms %s' % (build_location, rpm_names), exec_as_root=1)
		(code, output) = target_env.ssh.execute('rpm -Uvh %s/install-packages/*.rpm' % build_location, exec_as_root=1)

# Exit with return code...
sys.exit(code)

