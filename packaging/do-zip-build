#!/usr/bin/env python

import sys
import shutil
import os
import glob
import re
import distutils.dir_util

import utils
import packaging

rev = sys.argv[1]
package = sys.argv[2]
distro = sys.argv[3]
version = sys.argv[4]
build_location = sys.argv[5]

# Make sure it exists
if not os.path.exists(build_location):
	distutils.dir_util.mkpath(build_location)

os.chdir(build_location)

# Load def info
env = packaging.buildenv(distro)
pack_def = packaging.package(env, package, inside_jail=True)


for d in [ 'builder/built-packages', 'scratch', '/tmp/install' ]:
	if os.path.exists(d):
		shutil.rmtree(d)

os.mkdir('scratch')
os.chdir('scratch')

sources = glob.glob('../*.zip')
sources += glob.glob('../*.tar.gz')
sources += glob.glob('../*.tar.bz2')
patches = glob.glob('../*.patch')
patches.sort()

for f in sources + patches + ['../' + package, '../' + distro ]:
	shutil.move(f, '.')


# Find type of source
source_dir = utils.unpack_source(os.path.basename(sources[0]), tar_path=env.get_info_var('tar_path') )

arch = pack_def.package_env.info['arch']

os.chdir(source_dir)

# Apply patches if this package defines it
if pack_def.get_info_var('USE_PATCHES'):
	for patch in patches:
		if(os.system("patch -p1 < " + patch)):
			print "Failed applying patch: " + os.path.basename(patch)
			sys.exit(1)

# Get code from def file
shell_code = pack_def.get_zip_build_commands()

# Move def file so it gets cleaned up, and also saved with successful build
for f in pack_def.get_aliases():
	shutil.move(build_location + os.sep + f, '..')

# set version var, load up environment for deps, and execute build command
os.environ['version'] = version
build_command = shell_code

# Trying to load this missing file fails on solaris 10... ?
# Create an empty file if it's not there
if not os.path.exists('/tmp/build_deps'):
	os.mkdir('/tmp/build_deps')
if not os.path.exists('/tmp/build_deps/env.sh'):
	fd = open('/tmp/build_deps/env.sh', 'w')
	fd.write("")
	fd.close()

build_command = ". /tmp/build_deps/env.sh ; " + build_command
print build_command

# TODO:  For some reason the above exit isn't being called on failures
#  (Still an issue... ?)
if(os.system(build_command)):
	print "Build failed..."
	sys.exit(1)

# Package up the build (must not use build_location here for relocation correctness)
os.chdir('/tmp/install')
distutils.dir_util.mkpath(build_location + '/builder/built-packages')
os.system('zip -yr %s/builder/built-packages/%s-%s-%s.%s.zip *' % (build_location, package, version, rev, arch) )
# Keep a copy of the "spec" file and distro conf file
shutil.copy(build_location + '/scratch/' + package, build_location + '/builder/built-packages')
shutil.copy(build_location + '/scratch/' + distro, build_location + '/builder/built-packages')

# Keep the patches if they are used
if pack_def.get_info_var('USE_PATCHES'):
	for patch in patches:
		shutil.copy(build_location + '/scratch/' + os.path.basename(patch), build_location + '/builder/built-packages')

# Save alias files
for f in pack_def.get_aliases():
	shutil.copy(build_location + '/scratch/' + f, build_location + '/builder/built-packages')

