#!/usr/bin/env python
#
# Usage: build os-target package version [serial]
#
# Where:
#    os-target is the OS target that we are building for
#    package is the name of the BB XML configuration file on the repository
#    version is the version you want to build
#    serial is optionally the build number. If it is not present, it is assumed
#      to be zero.
#
# Example:
#    build suse-92-i386 mono 1.1.6
#

#TODO catch SIGQUIT and update status to 'killed'

import sys
import glob
import os.path
import distutils.dir_util
import signal

sys.path += [ '../pyutils' ]
import packaging
import logger
import utils
import datastore
import config

import pdb

timeout=1200

def get_state(code, test=0):
	if code == utils.KILLED_EXIT_CODE:
		return "timeout"
	elif code:
		if test:
			return "testfailure"
		else:
			return "failure"
	else:
		return "success"


if len(sys.argv) < 4:
	print "Usage is: ./build configuration package version <release>"
        print "  <release> is optional"
	sys.exit(1)

distro = sys.argv[1]
package_name = sys.argv[2]
version = sys.argv[3]

# If serial is passed in
if len(sys.argv) > 4:
	serial = sys.argv[4]
else:	serial = "0"

if serial == "0":
	ver_path = version
else:
	ver_path = version + "-" + serial

build_env = packaging.buildenv(distro)
package = packaging.package(build_env, package_name)


# check to see if this package is a valid build
if not package.info['BUILD_HOSTS'].count(distro):
	print "%s is not in BUILD_HOSTS" % distro
	sys.exit(3)


if build_env.is_locked():
	print "%s jail is busy" % distro
	sys.exit(2)

build_env.lock_env()

# Set signal handler
# TODO: How to fully kill builds on the client side???
def keyboard_interrupt(signum, frame):
	print 'Build aborted:', signum
	build_env.unlock_env()
signal.signal(signal.SIGINT, keyboard_interrupt)

if build_env.offline():
	print "%s jail is offline" % distro
	build_env.unlock_env()
	sys.exit(2)


revision = package.get_revision(serial)

# Set some defaults of where to find packages/sources
source_path = "sources"

# Figure out if this is a snapshot build or not...
#  Could do this by looking at the tarball map... ? (but ./build parameters would have to change)
sources = glob.glob("sources/%s/*-%s.tar.gz" % (package_name, version)) + glob.glob("sources/%s/*-%s.zip" % (package_name, version))
snapshot_sources = glob.glob("snapshot_sources/%s/*-%s.tar.gz" % (package_name, version)) + glob.glob("snapshot_sources/%s/*-%s.zip" % (package_name, version))
if sources:
	print "Using release sources and packages"
	HEAD_or_RELEASE = "RELEASE"
elif snapshot_sources:
	print "Using snapshot sources and packages"
	source_path = "snapshot_" + source_path
	HEAD_or_RELEASE = "HEAD"
else:
	print "Cannot find source file for " + package_name
	build_env.unlock_env()
	sys.exit(4)

sources += snapshot_sources
source_file = sources[0]

package_path = package.get_package_path(HEAD_or_RELEASE=HEAD_or_RELEASE)

print package_path

package_version_path = package_path + os.sep + ver_path


if os.path.exists(package_version_path):
	print "The path for this package (%s) already exists. You probably need to bump the revision number" % package_version_path
	build_env.unlock_env()
	sys.exit(5)

build_info = datastore.build_info(HEAD_or_RELEASE, distro, package_name, ver_path)
build_info.new_build()

# Update build step to running
build_info.update_build(state='inprogress', buildhost=build_env.info['target_host'], start=utils.get_time(), finish="")

# Debug
#values = build_info.get_build_info()
#pdb.set_trace()
#steps = build_info.get_steps_info()

# Update step: Add link to mktarball log
repo = datastore.source_file_repo()
logfile = repo.get_log_file(source_file)

# Create symbolic link to tarball in 'files' dir
# Create symbolic link to tarball_log in 'logs' dir
try:
	os.symlink(logfile, os.path.join(config.build_info_dir, build_info.rel_files_dir, 'logs', os.path.basename(logfile) ) )
	os.symlink(config.packaging_dir + os.sep + source_file, os.path.join(config.build_info_dir, build_info.rel_files_dir, 'files', os.path.basename(source_file) ) )
except OSError:
	# Usually means links are already there...
	pass

build_info.update_step("mktarball", state='success', log=os.path.basename(logfile), download=os.path.basename(source_file))

# Update step: installing deps
LOGFILE = os.path.join(config.build_info_dir, build_info.rel_files_dir, 'logs', 'install-deps.log')
log_obj = logger.Logger(filename=LOGFILE, print_screen=0)
build_info.update_step("install-deps", state="inprogress", log=os.path.basename(LOGFILE), start=utils.get_time(), finish="")

print "Installing dependencies..."
(code, output) = utils.launch_process("./install-deps %s %s" % (distro, package_name), logger=log_obj)
if code:
	build_env.unlock_env()
	build_info.update_step("install-deps", state="failure", finish=utils.get_time())
	build_info.update_build(state="failure", finish=utils.get_time())
	print "Dependency installation failed, see log in %s for details" % LOGFILE
	sys.exit(6)

build_info.update_step("install-deps", state="success", finish=utils.get_time())

# Debug
#build_env.unlock_env()
#sys.exit(1)

# Update step: building
LOGFILE = os.path.join(config.build_info_dir, build_info.rel_files_dir, 'logs', 'build.log')
log_obj = logger.Logger(filename=LOGFILE, print_screen=0)
build_info.update_step("build", state="inprogress", log=os.path.basename(LOGFILE), start=utils.get_time(), finish="")
# Copy tar.gz and zip files
files_to_copy = [ source_file ]

# Get the dir that tarball unpacks
#   Will this work with all tarballs?  This is what we do for do-zip-build...
build_dir = os.path.basename(source_file).replace('.tar.gz', '')
build_dir = build_dir.replace('.zip', '')

# Files for zip build system and build command
if build_env.info['USE_ZIP_PKG']:
	files_to_copy += ['do-zip-build', '../conf/%s/*.patch' % package_name, 'defs/%s' % package_name]
	build_command = '/tmp/do-zip-build %s %s %s %s' % (revision, package_name, distro, version)
	remote_src_dir = "/tmp/scratch/%s" % build_dir
	step_env_pre_cmd = ". /tmp/build_deps/env.sh; "

else:
	files_to_copy += ['do-build', '../conf/%s/*' % package_name ]
	build_command = '/tmp/do-build %s %s' % (version, revision)
	remote_src_dir = "/tmp/scratch/BUILD/%s" % build_dir
	step_env_pre_cmd = ""


build_env.ssh.copy_to(files_to_copy, '/tmp', mode='scp')

(code, output) = build_env.ssh.execute(build_command, logger=log_obj, output_timeout=timeout)
#code = 0
if code:
	build_env.unlock_env()
	state = get_state(code)
	print "Build failed, see log in %s for details" % LOGFILE
	build_info.update_step("build", state=state, finish=utils.get_time())
	build_info.update_build(state="failure", finish=utils.get_time())
	sys.exit(7)

distutils.dir_util.mkpath(package_version_path)
build_env.ssh.copy_from(['/tmp/builder/built-packages/*', '/tmp/scratch/*.spec'], package_version_path)

# Create link to packages
try:
	os.symlink(package_version_path, os.path.join(config.build_info_dir, build_info.rel_files_dir, 'files', 'downloads' ) )
except OSError:
	# Probably already exists...
	pass

build_info.update_step("build", state="success", download=os.path.basename('downloads'), finish=utils.get_time())

# Run postbuild steps
remote_env = {}
remote_env['HEAD_or_RELEASE'] = "HEAD"
counter = 1
while(1):
	if package.info.has_key('POSTBUILD_STEP_NAME%d' % counter) and package.info.has_key('POSTBUILD_STEP%d' % counter):
		print "Running step %d!" % counter
		name = package.info['POSTBUILD_STEP_NAME%d' % counter]
		LOGFILE = os.path.join(config.build_info_dir, build_info.rel_files_dir, 'logs', '%s.log' % name)
		log_obj = logger.Logger(filename=LOGFILE, print_screen=0)
		build_info.update_step(name, state="inprogress", log=os.path.basename(LOGFILE), start=utils.get_time(), finish="")

		(code, output) = build_env.ssh.execute("%s cd %s  " % (step_env_pre_cmd, remote_src_dir + package.info['POSTBUILD_STEP%d' % counter] ), env=remote_env, logger=log_obj, output_timeout=timeout)
		state = get_state(code, test=1)
		if code:
			print "Step %d (%s) failed..." % (counter, package.info['POSTBUILD_STEP_NAME%d' % counter])
			build_info.update_step(name, state=state, finish=utils.get_time())
		else:
			build_info.update_step(name, state=state, finish=utils.get_time())
	else:
		break

	counter += 1

state = build_info.get_collective_state()
build_info.update_build(state=state, finish=utils.get_time())

build_env.unlock_env()

print "Done!"

