#!/usr/bin/env python
#
# Usage: build os-target package version [serial]
#
# Where:
#    os-target is the OS target that we are building for
#    package is the name of the BB XML configuration file on the repository
#    version is the version you want to build
#    serial is optionally the build number. If it is not present, it is assumed
#      to be zero.
#
# Example:
#    build suse-92-i386 mono-1.1 1.1.6
#

import sys
import glob
import os.path
import distutils.dir_util

sys.path += [ '../pyutils' ]
import packaging
import logger
import utils


if len(sys.argv) < 4:
	print "Usage is: ./build configuration package version <release>"
        print "  <release> is optional"
	sys.exit(1)

distro = sys.argv[1]
package_name = sys.argv[2]
version = sys.argv[3]

# If serial is passed in
if len(sys.argv) > 4:
	serial = sys.argv[4]
	ver_path = version + "-" + serial
else:
	serial = "0"
	ver_path = version


LOGFILE = "logs/%s-%s-%s-%s" % ( package_name, version, serial, distro)
log_obj = logger.Logger(filename=LOGFILE, print_screen=0)

build_env = packaging.buildenv(distro, logger=log_obj)
package = packaging.package(build_env, package_name)

if build_env.is_locked():
	print "%s jail is busy" % distro
	sys.exit(1)

# check to see if this package is a valid build
if not package.info['BUILD_HOSTS'].count(distro):
	print "%s is not in BUILD_HOSTS" % distro
	sys.exit(1)

destroot = package.destroot

ver_path
revision = package.get_revision(serial)

# Set some defaults of where to find packages/sources
source_path = "sources"

# Figure out if this is a snapshot build or not...
if glob.glob("sources/%s/*-%s.tar.gz" % (package_name, version)) or glob.glob("sources/%s/*-%s.zip" % (package_name, version)):
	snapshot = 0
	print "Using release sources and packages"
elif glob.glob("snapshot_sources/%s/*-%s.tar.gz" % (package_name, version)) or glob.glob("snapshot_sources/%s/*-%s.zip" % (package_name, version)):
	print "Using snapshot sources and packages"
	snapshot = 1
	source_path = "snapshot_" + source_path
else:
	print "Cannot find source file for " + package_name
	sys.exit(1)

package_path = package.get_package_path(snapshot=snapshot)

print package_path

package_version_path = package_path + os.sep + ver_path


if os.path.exists(package_version_path):
	print "The path for this package (%s) already exists. You probably need to bump the revision number" % package_version_path
	sys.exit(1)


build_env.lock_env()

print "Installing dependencies..."
(code, output) = utils.launch_process("./install-deps %s %s" % (distro, package_name), logger=log_obj)
if code:
	build_env.unlock_env()
	print "Dependency installation failed, see log in %s for details" % LOGFILE
	sys.exit(1)


# Copy tar.gz and zip files
files_to_copy = [ '%s/%s/*-%s.tar.gz' % (source_path, package_name, version), '%s/%s/*-%s.zip' % (source_path, package_name, version) ]

# Files for zip build system and build command
if build_env.info['USE_ZIP_PKG']:
	files_to_copy += ['do-zip-build', '../conf/%s/*.patch' % package_name, 'defs/%s' % package_name]
	build_command = '/tmp/do-zip-build %s %s %s %s' % (revision, package_name, distro, version)

else:
	files_to_copy += ['do-build', '../conf/%s/*' % package_name ]
	build_command = '/tmp/do-build %s %s' % (version, revision)


build_env.ssh.copy_to(files_to_copy, '/tmp', mode='scp')

(code, output) = build_env.ssh.execute(build_command)
if code:
	build_env.unlock_env()
	print "Build failed, see log in %s for details" % LOGFILE
	sys.exit(1)

distutils.dir_util.mkpath(package_version_path)
build_env.ssh.copy_from(['/tmp/builder/built-packages/*', '/tmp/scratch/*.spec'], package_version_path)

build_env.unlock_env()


