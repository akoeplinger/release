#!/usr/bin/env python

import sys
import os
import os.path
import shutil
import distutils.dir_util
import glob
import re

sys.path += [ '../pyutils' ]

import packaging
import utils

# BOO Syntax highlighting is going to take some more porting... look at this file: opt/gnome/share/gtksourceview-1.0/language-specs/boo.lang for steps on how to do this
# There's a problem with the version of gtksourceview that we use... it is unable to check for *.lang files in the location where the installer installs mono

DOWNLOAD_URL = "http://primates.ximian.com/~wberrier/linux-installer"
IB_VER = "3.0.1"

# The following list is grouped as deps for: (discovered using ldd)
# mono
# mono-debugger
# libgdiplus

# Probably won't ship gtk# until we provide fallback libraries like vmware does.

# These should be the same as the sles-9 versions
external_rpms_list = """
	ftp://ftp.suse.com/pub/suse/discontinued/i386/9.1/suse/i586/pkgconfig-0.15.0-194.i586.rpm
	ftp://ftp.suse.com/pub/suse/discontinued/i386/9.1/suse/i586/ncurses-5.4-59.i586.rpm

	ftp://ftp.suse.com/pub/suse/discontinued/i386/9.1/suse/i586/libtiff-3.6.1-38.i586.rpm
	ftp://ftp.suse.com/pub/suse/discontinued/i386/9.1/suse/i586/libungif-4.1.0b1-581.i586.rpm
	ftp://ftp.suse.com/pub/suse/discontinued/i386/9.1/suse/i586/libpng-1.2.5-182.i586.rpm
	ftp://ftp.suse.com/pub/suse/discontinued/i386/9.1/suse/i586/libjpeg-6.2.0-731.i586.rpm
	ftp://ftp.suse.com/pub/suse/discontinued/i386/9.1/suse/i586/zlib-1.2.1-70.i586.rpm
	ftp://ftp.suse.com/pub/suse/discontinued/i386/9.1/suse/i586/expat-1.95.7-37.i586.rpm
""".split()

# What's gal2 for?
	#http://suse.mirrors.tds.net/pub/opensuse/distribution/SL-10.0-OSS/inst-source/suse/i586/gal2-2.5.3-5.i586.rpm
custom_rpms_list = """
	http://suse.mirrors.tds.net/pub/opensuse/distribution/SL-10.0-OSS/inst-source/suse/i586/gtkhtml2-3.8.0-3.i586.rpm
	http://suse.mirrors.tds.net/pub/opensuse/distribution/SL-10.0-OSS/inst-source/suse/i586/gtksourceview-1.4.1-2.i586.rpm
""".split()

# rpm locations we build locally
local_rpms = [ 
	{'name': 'sles-9-i586', 'packages': [
		"mono",
		"mono-debugger",
		"heap-buddy",
		"libgdiplus",

		"boo",
		"xsp",
		"ikvm",
		"monodoc",
		"nant",
		"IPCE",
		"mono-basic",

		] },
	{'name': 'suse-100-i586', 'packages': [
		"gtk-sharp",
		"gtk-sharp28",
                "mono-tools",
                "monodevelop",
                "gecko-sharp",
                "gecko-sharp2",
                "gtksourceview-sharp2",
		] }

]

prefix = os.getcwd()

buildroot = prefix + "/build"
external_rpms = prefix + "/external_rpms"

readme_text = ""
packages_used_text = "RPMS used to create this build:\n\n"

################ Helper routine ##############################

# Recursively change directores to 755
#  TODO: is this needed?
def recurse_directories(directory):

	os.chmod(directory, 0755)

	files = glob.glob(directory + "/*")

	for file in files:
		if os.path.isdir(file):
			recurse_directories(file)
		# If it ends in .exe, make it executable (This is a hack for now, because the rpms should already have these permissions set...)
		elif re.compile("\.exe$").search(file):
			os.chmod(file, 0755)

##############################################################


# Command line arg checking
if len(sys.argv) < 2:
	print 
	print "Usage: buildlinux-installer <mono version> [<release>]"
	print "  Example: buildlinux-installer 1.1.7"
	print "  Example: buildlinux-installer 1.1.8.1 1"
	print 
	sys.exit(1)

# Version passed in from the command line
mono_version = sys.argv[1]
if len(sys.argv) > 2:
	mono_release_version = sys.argv[2]
else:   mono_release_version = "0"

output = os.path.join(prefix, 'output', mono_version, 'linux-installer', mono_release_version)

if os.path.exists(output):
	print output + " already exists... please remove this dir or bump the package release version"
	sys.exit(1)

mono_installer_output = os.environ['HOME'] + "/installbuilder-%s/output/mono-%s-installer.bin" % (IB_VER, mono_version)

# check for installer and install if it isn't there
if not os.path.exists(os.environ['HOME'] + "/installbuilder-%s/bin/builder" % IB_VER):
	
	installer = "installbuilder-enterprise-%s-linux-installer.bin" % IB_VER

	# Doesn't redownload if not needed
	print "Downloading the Bitrock installer...";
	utils.get_url(os.path.join(DOWNLOAD_URL, 'bitrock', installer), '/tmp')
	os.chmod ("/tmp/" + installer, 0755)

	print "Installing the Bitrock installer..."
	os.system("/tmp/%s --mode unattended" % installer)

# Check for license file
license_file = os.environ['HOME'] + "/installbuilder-%s/license.xml" % IB_VER
if not os.path.exists(license_file):

	if os.path.exists(prefix + os.sep + "novell.xml"):
		shutil.copy(prefix + "/novell.xml", license_file)
	else:
		print "Please place novell.xml in %s or copy license.xml to %s before proceeding" % (prefix, license_file)
		sys.exit(1)

	if not os.path.exists(license_file):
		print "Still cannot find %s" % license_file
		sys.exit(1);


# Cleanup
if os.path.exists(buildroot):
	shutil.rmtree(buildroot)
os.mkdir(buildroot)

# Download the stock and custom rpms if they don't exist already and add them to the extraction list
files = []
cwd = os.getcwd()
if not os.path.exists(external_rpms):
	os.mkdir(external_rpms)

for url in external_rpms_list + custom_rpms_list:
	utils.get_url(url, external_rpms)
	files.append(external_rpms + os.sep + os.path.basename(url))

# Collect local rpm files
for selection in local_rpms:

	conf = packaging.buildconf(selection['name'], skip_alternates=True)

	for pack in selection['packages']:
		pack_obj = packaging.package(conf, pack)
		files += pack_obj.get_files()

# Extract all the rpms
os.chdir(buildroot)
packages = []
for file in files:
	packages.append( utils.extract_file(file, preserve_symlinks=1, truncate_path="") )

packages.sort()
packages_used_text += "\n".join(packages) + "\n"

# The tcl version of the this script got the "normalized" full path to the file... this should work
p = buildroot

# Other permissions that do not get set... gapi_codegen.exe, gapi-fixup.exe, #does this matter?  Probably... because there's that one feature which will invoke mono on certain types of binaries... this should probably happen in the rpm though so it gets fixed in both places...

os.chdir(p)

## Move files under usr instead of using opt
distutils.dir_util.copy_tree("opt/gnome", "usr", preserve_symlinks=1)
shutil.rmtree('opt')

# Move etc under usr since we will collect all files under usr for installer
os.rename("etc", "usr/etc")

# Location substitution for the pkgconfig files...
for f in glob.glob(p + "/usr/lib/pkgconfig/*.pc"):
	utils.substitute_parameters_in_file(f, {'/usr' : '@@BITROCK_MONO_ROOTDIR@@'} )

# Create setup.sh for sourcing in bash files
setup = open(p + "/usr/bin/setup.sh", 'w')
setup.write("""#!/bin/sh

export PATH="@@BITROCK_MONO_ROOTDIR@@/bin:$PATH"
export LD_LIBRARY_PATH="@@BITROCK_MONO_ROOTDIR@@/lib:$LD_LIBRARY_PATH"
export PKG_CONFIG_PATH="@@BITROCK_MONO_ROOTDIR@@/lib/pkgconfig:$PKG_CONFIG_PATH"
export MANPATH="@@BITROCK_MONO_ROOTDIR@@/share/man:$MANPATH"
""")
setup.close()
os.chmod(p + "/usr/bin/setup.sh", 0755)

executable_wrappers = []
for f in glob.glob(p + "/usr/bin/*"):

	fd = open(f)
	text = fd.read()
	fd.close()

	if re.compile("#! ?\/bin\/sh").search(text):
		executable_wrappers.append(os.path.basename(f))


for f in executable_wrappers:
	if os.path.exists(p + "/usr/bin/" + f):
		utils.substitute_parameters_in_file(p + "/usr/bin/" + f, 
			{ '/usr' 			: '@@BITROCK_MONO_ROOTDIR@@'
			# Add full path for these... ?
			#'exec mono' 		: 'exec @@BITROCK_MONO_ROOTDIR@@/bin/mono',
			# This was added I believe for the debugger, but don't think it's needed
			#'mono --debug'	 	: 'exec @@BITROCK_MONO_ROOTDIR@@/bin/mono --debug'
		} )
	else:
		print "***Not found %s/usr/bin/%s***" % (p, f)

# Fix wrappers that have .desktop entries so that the user doesn't need to reload their environment in order to load the apps
# TODO: These may need to be updated as these wrappers change
for f in ['monodoc', 'monodevelop']:
	utils.substitute_parameters_in_file(p + "/usr/bin/" + f,
		{ '#! ?/bin/sh'	:
"""#!/bin/sh

# Added by Mono Bitrock installer
. @@BITROCK_MONO_ROOTDIR@@/bin/setup.sh
"""
		}
	)


# This glob should only return one file...
utils.substitute_parameters_in_file( glob.glob(p + "/usr/lib/mono/gac/monodoc/1.0*/monodoc.dll.config").pop(),
	{ '/usr': '@@BITROCK_MONO_ROOTDIR@@' } )

# Add some sections for gtksourceview to integrate boo

boo_config_file_additions = {
#	p + "/usr/share/mime-info/gtksourceview-sharp.keys" :
#"""text/x-boo
#	category=Software Development/Source Code
#	can_be_executable=true
#	default_action_type=application
#	description=boo source code
#	short_list_application_ids_for_novice_user_level=monodevelop,gedit
#
#""",
#	p + "/usr/share/mime-info/gtksourceview-sharp.mime" :
#"""text/x-boo
#	ext: boo
#"""

	}

utils.append_text_to_files(boo_config_file_additions)
# TODO: Not working quite yet...
#$readme_text .= "\nYou may need to run 'update-mime-database /usr/share/mime' in order to fully integrate boo syntax highlighting.\n";

# Fix broken tiff package (package should contain this link, but doesn't)
os.chdir("usr/lib")
if not os.path.exists("libtiff.so.3"):
	os.symlink("libtiff.so.3.5", "libtiff.so.3")
os.chdir("../..")

# ncurses for suse 9.1 has files under /lib instead of /usr/lib, fix up
os.chdir("lib")
for f in os.listdir('.'):
	shutil.move(f, '../usr/lib')
os.chdir("..")
os.rmdir('lib')

shutil.copy(p + "/../projects/mono.xml", p)
utils.substitute_parameters_in_file(p + "/mono.xml", { '@@VERSION@@': mono_version } )

distutils.dir_util.mkpath(p + "/usr/share/pixmaps")
shutil.copy(p + "/../projects/mono/readme.gif", p + "/usr/share/pixmaps")
shutil.copy(p + "/../projects/mono/monourl.gif", p + "/usr/share/pixmaps")
shutil.copy(p + "/../projects/mono/monotm48x48.png", p + "/usr/share/pixmaps")
shutil.copy(p + "/../projects/mono/License.txt", p + "/usr/share/doc")

# Take care of the Readme file
fd = open(p + "/../projects/Readme.txt")
readme_text += fd.read() + "\n\n"
readme_text += packages_used_text + "\n"
fd.close()
fd = open(p + "/usr/share/doc/Readme.txt", 'w')
fd.write(readme_text)
fd.close()

utils.substitute_parameters_in_file(p + "/usr/share/doc/Readme.txt", {'@@VERSION@@' : mono_version } )

os.mkdir(p + "/html")
# TODO: Here's another file that changes with each release... need to update it manually for now
shutil.copy(p + "/../projects/mono/html/index.html", p + "/html")

shutil.copy(p + "/../projects/mono/html/mono.css", p + "/html")
shutil.copy(p + "/../projects/mono/html/bitrock.png", p + "/html")

# Copy installer helper scripts
shutil.copy(p + "/../projects/post_libscan", p + "/usr/bin/.installer_post_libscan")
shutil.copy(p + "/../projects/pre_env_setup", p + "/usr/bin/.installer_pre_env_setup")

# Generate some stuff in mono.xml
result = ""

# Get a list of files to substitute
for item in executable_wrappers:
	result += "*/bin/%s;" % item

result += "*/monodoc.dll.config;*/*.pc"

# We don't need to substitute here because bitrock shows the unsubstituted version
#result += ";*/Readme.txt"

utils.substitute_parameters_in_file(p + "/mono.xml",
    { '@@SUBST_FILES@@' : result } )

# Fix RPM directory permissions (chmod to 0755)
recurse_directories(p + "/usr/")

# Run the install
os.system("%s/installbuilder-%s/bin/builder build %s/mono.xml" % (os.environ['HOME'], IB_VER, p) )

# Move file to the current
if os.path.exists(mono_installer_output):

	# Keep record of which packages went into this build...
	distutils.dir_util.mkpath(output)
	fd = open(output + os.sep + "packages_used.txt", 'w')
	fd.write(packages_used_text)
	fd.close()

	# Move the install binary to the current directory
	final_output_file = "%s/mono-%s_%s-installer.bin" % (output, mono_version, mono_release_version) 
	os.rename(mono_installer_output, final_output_file )
	# Do md5sum generation
	os.chdir(output)
	os.system("md5sum *.bin > %s.md5" % os.path.basename(final_output_file) )


